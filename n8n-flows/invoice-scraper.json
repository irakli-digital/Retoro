{
  "nodes": [
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "create-retailer-condition",
              "leftValue": "={{ $json.retailer_found }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2096,
        1488
      ],
      "id": "aad60df3-33bf-413e-834e-416e8f978821",
      "name": "Check If Retailer Exists"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Edit Fields').item.json.RETORO_API_URL }}/retailers",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "name",
              "value": "={{ $json.retailer_name }}"
            },
            {
              "name": "return_window_days",
              "value": "={{ $json.default_return_window_days || 30 }}"
            },
            {
              "name": "website_url",
              "value": "={{ $json.retailer_name.includes('.') ? 'https://' + $json.retailer_name : null }}"
            },
            {
              "name": "has_free_returns",
              "value": "=false"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "e2a903c7-c9c4-4259-9cff-cb4d8bf4ef48",
      "name": "Create Retailer",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        2320,
        1560
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "6uoywV79GxAzcFU4",
          "name": "RTR - IC"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// After creating retailer, format it to match the expected structure\nconst createdRetailer = $input.item.json;\nconst parseData = $('Parse Invoice Data1').item.json;\n\nconsole.log('Created retailer:', createdRetailer);\nconsole.log('Parse data:', parseData);\n\n// Ensure items array is preserved for Split Items node\nreturn {\n  json: {\n    retailer_id: createdRetailer.id,\n    retailer_name: createdRetailer.name,\n    retailer_found: true,\n    seller_name: parseData.seller_name,\n    total_amount: parseData.total_amount,\n    items: parseData.items || [], // Ensure items array is preserved\n    user_id: parseData.user_id, // Preserve user_id\n    raw_response: parseData.raw_response\n  }\n};"
      },
      "id": "3d20fb57-6389-4210-b628-0a115f7592db",
      "name": "Format Created Retailer",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2544,
        1560
      ]
    },
    {
      "parameters": {
        "jsCode": "// Process all items in runOnceForAllItems mode\nconst results = [];\n\n// Get user_id from webhook query parameters (preserve it through the flow)\nconst webhookData = $('Webhook Trigger1').item.json;\n// Query params are accessible via $json.query in n8n\nconst userId = webhookData.query?.user_id || webhookData.user_id || webhookData.userId;\n\nconsole.log('=== Parse Invoice Data1 - User ID Debug ===');\nconsole.log('Webhook data:', JSON.stringify(webhookData, null, 2));\nconsole.log('Extracted user_id:', userId);\n\nfor (const input of $input.all()) {\n  let invoiceData;\n  \n  try {\n    let content;\n    \n    // Handle the specific Mistral/Claude response format\n    if (input.json.output && Array.isArray(input.json.output) && input.json.output[0]) {\n      // Your specific format: output[0].content[0].text\n      const message = input.json.output[0];\n      if (message.content && Array.isArray(message.content) && message.content[0]) {\n        content = message.content[0].text;\n      }\n    }\n    // Fallback for other AI response formats\n    else if (input.json.choices && input.json.choices[0]?.message?.content) {\n      content = input.json.choices[0].message.content;\n    } \n    else if (input.json.content) {\n      content = input.json.content;\n    } \n    else if (typeof input.json === 'string') {\n      content = input.json;\n    } \n    else {\n      content = JSON.stringify(input.json);\n    }\n    \n    // If content is already an object, use it directly\n    if (typeof content === 'object') {\n      invoiceData = content;\n    } else {\n      // Extract JSON from string content (handle markdown code blocks)\n      const jsonMatch = content.match(/```(?:json)?\\s*([\\s\\S]*?)```/) || content.match(/\\{[\\s\\S]*\\}/);\n      \n      if (jsonMatch) {\n        const jsonString = jsonMatch[1] || jsonMatch[0];\n        invoiceData = JSON.parse(jsonString.trim());\n      } else {\n        invoiceData = JSON.parse(content);\n      }\n    }\n    \n  } catch (e) {\n    throw new Error(`Failed to parse invoice data: ${e.message}. Response: ${JSON.stringify(input.json)}`);\n  }\n  \n  // Validate required fields (matching your schema)\n  if (!invoiceData.seller_name) {\n    throw new Error('Seller name not found in invoice');\n  }\n  \n  if (!invoiceData.items || !Array.isArray(invoiceData.items) || invoiceData.items.length === 0) {\n    throw new Error('No items found in invoice');\n  }\n  \n  // Map items to ensure all required fields exist\n  const mappedItems = invoiceData.items.map(item => ({\n    item_name: item.item_name || 'Unnamed Item',\n    item_cost: item.item_cost || 0,\n    item_quantity: item.item_quantity || 1,\n    item_currency: item.item_currency || 'USD'\n  }));\n  \n  // Calculate total if not provided\n  const totalAmount = mappedItems.reduce((sum, item) => \n    sum + (item.item_cost * item.item_quantity), 0\n  );\n  \n  results.push({\n    json: {\n      seller_name: invoiceData.seller_name,\n      total_amount: totalAmount,\n      items: mappedItems,\n      user_id: userId, // Preserve user_id from webhook\n      raw_response: input.json // Keep original for debugging\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "94d42ffd-9584-48ba-9962-df00e78a138a",
      "name": "Parse Invoice Data1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        1488
      ]
    },
    {
      "parameters": {
        "url": "={{ $json.RETORO_API_URL }}/retailers?search={{ encodeURIComponent($json.seller_name) }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "672a8b13-c99f-478d-9a27-e8e29a8335a4",
      "name": "Search Retailer2",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1648,
        1488
      ],
      "alwaysOutputData": true,
      "credentials": {
        "httpHeaderAuth": {
          "id": "6uoywV79GxAzcFU4",
          "name": "RTR - IC"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Match retailer from search results\nlet searchResults = $input.item.json;\n\n// If no input data, try to get from previous node\nif (!searchResults || (typeof searchResults === 'object' && Object.keys(searchResults).length === 0)) {\n  const previousNode = $('Search Retailer2');\n  if (previousNode && previousNode.item && previousNode.item.json) {\n    searchResults = previousNode.item.json;\n  }\n}\n\n// Get seller name from invoice data\nconst invoiceRetailerName = $('Parse Invoice Data1').item.json.seller_name;\nconst invoiceRetailerNameLower = invoiceRetailerName.toLowerCase().trim();\n\n// Debug logging\nconsole.log('=== Match Retailer2 Debug ===');\nconsole.log('Search results type:', typeof searchResults);\nconsole.log('Search results:', JSON.stringify(searchResults, null, 2));\nconsole.log('Looking for retailer:', invoiceRetailerNameLower);\n\n// Parse results array - handle different response formats\nlet results = null;\nif (Array.isArray(searchResults)) {\n  results = searchResults;\n} else if (searchResults && Array.isArray(searchResults.data)) {\n  results = searchResults.data;\n} else if (searchResults && searchResults.json && Array.isArray(searchResults.json)) {\n  results = searchResults.json;\n} else if (searchResults && typeof searchResults === 'object') {\n  // Try to find array in the object\n  const keys = Object.keys(searchResults);\n  for (const key of keys) {\n    if (Array.isArray(searchResults[key])) {\n      results = searchResults[key];\n      break;\n    }\n  }\n}\n\nconsole.log('Parsed results array length:', results ? results.length : 0);\nif (results && results.length > 0) {\n  console.log('Available retailers:', results.map(r => `${r.name || 'N/A'} (ID: ${r.id || 'N/A'})`).join(', '));\n}\n\n// CRITICAL: If we have ANY results, we should match at least one\n// Only return false if we truly have NO results\nif (!results || results.length === 0) {\n  console.log(`❌ No search results returned for '${invoiceRetailerName}'. Will create with default values.`);\n  return {\n    json: {\n      retailer_found: false,\n      retailer_name: invoiceRetailerName,\n      needs_creation: true,\n      default_return_window_days: 30,\n      ...$('Parse Invoice Data1').item.json\n    }\n  };\n}\n\n// We have results - try to find the best match\nlet matchedRetailer = null;\n\n// 1. Exact match on name\nmatchedRetailer = results.find(r => r.name && r.name.toLowerCase().trim() === invoiceRetailerNameLower);\nif (matchedRetailer) {\n  console.log(`✅ Exact name match: ${matchedRetailer.name} (ID: ${matchedRetailer.id})`);\n}\n\n// 2. Exact match on ID\nif (!matchedRetailer) {\n  const expectedId = invoiceRetailerNameLower.replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');\n  matchedRetailer = results.find(r => r.id && r.id.toLowerCase() === expectedId);\n  if (matchedRetailer) {\n    console.log(`✅ Exact ID match: ${matchedRetailer.id} (name: ${matchedRetailer.name})`);\n  }\n}\n\n// 3. Name contains match\nif (!matchedRetailer) {\n  matchedRetailer = results.find(r => {\n    const rName = (r.name || '').toLowerCase().trim();\n    return rName.includes(invoiceRetailerNameLower) || invoiceRetailerNameLower.includes(rName);\n  });\n  if (matchedRetailer) {\n    console.log(`✅ Contains match: ${matchedRetailer.name} (ID: ${matchedRetailer.id})`);\n  }\n}\n\n// 4. ID contains match\nif (!matchedRetailer) {\n  matchedRetailer = results.find(r => {\n    const rId = (r.id || '').toLowerCase();\n    return rId.includes(invoiceRetailerNameLower) || invoiceRetailerNameLower.includes(rId);\n  });\n  if (matchedRetailer) {\n    console.log(`✅ ID contains match: ${matchedRetailer.id} (name: ${matchedRetailer.name})`);\n  }\n}\n\n// 5. Website URL domain match\nif (!matchedRetailer) {\n  matchedRetailer = results.find(r => {\n    if (!r.website_url) return false;\n    try {\n      const url = new URL(r.website_url);\n      const domain = url.hostname.replace(/^www\\./, '');\n      return domain === invoiceRetailerNameLower || domain.includes(invoiceRetailerNameLower) || invoiceRetailerNameLower.includes(domain);\n    } catch (e) {\n      return false;\n    }\n  });\n  if (matchedRetailer) {\n    console.log(`✅ Website URL match: ${matchedRetailer.website_url} (name: ${matchedRetailer.name})`);\n  }\n}\n\n// 6. Word boundary match\nif (!matchedRetailer) {\n  const searchWithoutTld = invoiceRetailerNameLower.replace(/\\.(com|net|org|io|ge|co|app|dev)$/, '');\n  const searchWords = searchWithoutTld.split(/[\\s\\-\\.]+/).filter(w => w.length > 0);\n  \n  matchedRetailer = results.find(r => {\n    const rName = (r.name || '').toLowerCase().replace(/\\.(com|net|org|io|ge|co|app|dev)$/, '');\n    const rId = (r.id || '').toLowerCase();\n    const nameWords = rName.split(/[\\s\\-\\.]+/).filter(w => w.length > 0);\n    const idWords = rId.split(/[\\s\\-\\.]+/).filter(w => w.length > 0);\n    \n    return nameWords.some(word => searchWords.includes(word)) ||\n           searchWords.some(word => nameWords.includes(word)) ||\n           idWords.some(word => searchWords.includes(word)) ||\n           searchWords.some(word => idWords.includes(word));\n  });\n  if (matchedRetailer) {\n    console.log(`✅ Word boundary match: ${matchedRetailer.name} (ID: ${matchedRetailer.id})`);\n  }\n}\n\n// 7. FALLBACK: If we have results but no match, use the first one\n// This ensures we always return retailer_found: true if results exist\nif (!matchedRetailer && results.length > 0) {\n  matchedRetailer = results[0];\n  console.log(`⚠️ Using first result as fallback: ${matchedRetailer.name} (ID: ${matchedRetailer.id})`);\n  console.log(`⚠️ Note: This means search returned results but no exact match was found.`);\n}\n\n// At this point, if we have results, matchedRetailer should always be set\n// If it's still null, something went wrong\nif (!matchedRetailer) {\n  console.error(`❌ ERROR: Results exist (${results.length}) but matchedRetailer is null!`);\n  console.error('Results:', JSON.stringify(results, null, 2));\n  // Still return false to trigger creation\n  return {\n    json: {\n      retailer_found: false,\n      retailer_name: invoiceRetailerName,\n      needs_creation: true,\n      default_return_window_days: 30,\n      ...$('Parse Invoice Data1').item.json\n    }\n  };\n}\n\n// Retailer found - ALWAYS return true if we have a match\nconsole.log(`✅ Final match: ${matchedRetailer.name} (ID: ${matchedRetailer.id})`);\nreturn {\n  json: {\n    retailer_found: true,\n    retailer_id: matchedRetailer.id,\n    retailer_name: matchedRetailer.name,\n    needs_creation: false,\n    ...$('Parse Invoice Data1').item.json\n  }\n};"
      },
      "id": "8204ae19-0926-4235-9fc9-d4590c057fb3",
      "name": "Match Retailer2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1872,
        1488
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Edit Fields').item.json.RETORO_API_URL }}/return-items",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "retailer_id",
              "value": "={{ $json.retailer_id }}"
            },
            {
              "name": "name",
              "value": "={{ $json.item_name }}"
            },
            {
              "name": "price",
              "value": "={{ $json.item_cost }}"
            },
            {
              "name": "purchase_date",
              "value": "={{ $json.purchase_date || new Date().toISOString() }}"
            },
            {
              "name": "user_id",
              "value": "={{ $('Edit Fields').item.json.user_id || $json.user_id }}"
            },
            {
              "name": "currency",
              "value": "={{ $json.item_currency || 'USD' }}"
            }
          ]
        },
        "options": {}
      },
      "id": "9365fc3a-3584-4016-b17a-185764460a74",
      "name": "Create Return Item2",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        3008,
        1488
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "6uoywV79GxAzcFU4",
          "name": "RTR - IC"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Aggregate results\nconst items = $input.all();\nconst itemsCreated = items.map(item => item.json.id || item.json.item_id);\n\n// Get retailer name from Match Retailer node\nconst retailerName = $('Match Retailer2').item.json.retailer_name;\n\nreturn {\n  json: {\n    items_created: itemsCreated,\n    retailer_matched: retailerName,\n    items_count: itemsCreated.length,\n    errors: []\n  }\n};"
      },
      "id": "4c1b8d2e-250c-4ec9-b9f2-a0faa18f2fe7",
      "name": "Aggregate Results2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3440,
        1488
      ]
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "chatgpt-4o-latest",
          "mode": "list",
          "cachedResultName": "CHATGPT-4O-LATEST"
        },
        "responses": {
          "values": [
            {
              "content": "=You are an invoice data extraction assistant. Extract the following information from invoices, receipts, or payment confirmations from below text:\n\n{{ $json.pages[0].markdown }}\n\nREQUIRED FIELDS:\n- seller_name: The company/merchant name (seller)\n- items: Array of purchased items/services with:\n  - item_name: Product or service name\n  - item_cost: Price per unit (numeric value only, no currency symbol)\n  - item_quantity: Number of units (default to 1 if not specified)\n  - item_currency: Currency code (e.g., GEL, USD, EUR)\n\nEXTRACTION RULES:\n1. If multiple items exist, create separate entries in the items array\n2. Extract only numeric values for costs (remove currency symbols)\n3. Use standard 3-letter currency codes (ISO 4217)\n4. If quantity is not mentioned, assume quantity = 1\n5. If any field cannot be found, use null\n\nOUTPUT FORMAT:\nReturn valid JSON matching the provided schema. Do not include any explanatory text outside the JSON.\n```\n\n---\n\n## **JSON Schema:**\n\n```json\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"seller_name\": {\n      \"type\": \"string\",\n      \"description\": \"Company or merchant name\"\n    },\n    \"items\": {\n      \"type\": \"array\",\n      \"description\": \"List of purchased items\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"item_name\": {\n            \"type\": \"string\",\n            \"description\": \"Product or service name\"\n          },\n          \"item_cost\": {\n            \"type\": \"number\",\n            \"description\": \"Price per unit (numeric only)\"\n          },\n          \"item_quantity\": {\n            \"type\": \"integer\",\n            \"description\": \"Number of units purchased\",\n            \"default\": 1\n          },\n          \"item_currency\": {\n            \"type\": \"string\",\n            \"description\": \"Currency code (ISO 4217)\",\n            \"pattern\": \"^[A-Z]{3}$\"\n          }\n        },\n        \"required\": [\"item_name\", \"item_cost\", \"item_quantity\", \"item_currency\"],\n        \"additionalProperties\": false\n      },\n      \"minItems\": 1\n    }\n  },\n  \"required\": [\"seller_name\", \"items\"],\n  \"additionalProperties\": false\n}\n```\n\n---\n\n## **Expected Output for our Example:**\n\n```json\n{\n  \"seller_name\": \"mypen.ge\",\n  \"items\": [\n    {\n      \"item_name\": \"Mypen PRO Subscription\",\n      \"item_cost\": 29.0,\n      \"item_quantity\": 1,\n      \"item_currency\": \"GEL\"\n    }\n  ]\n}\n```\n\n---\n\n## **For Multiple Items Example:**\n\nIf the invoice had multiple items, it would look like:\n\n```json\n{\n  \"seller_name\": \"mypen.ge\",\n  \"items\": [\n    {\n      \"item_name\": \"Mypen PRO Subscription\",\n      \"item_cost\": 29.0,\n      \"item_quantity\": 1,\n      \"item_currency\": \"GEL\"\n    },\n    {\n      \"item_name\": \"Premium Support\",\n      \"item_cost\": 15.0,\n      \"item_quantity\": 2,\n      \"item_currency\": \"GEL\"\n    }\n  ]\n}\n"
            }
          ]
        },
        "builtInTools": {},
        "options": {
          "textFormat": {
            "textOptions": {
              "type": "json_schema",
              "schema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"seller_name\": {\n      \"type\": \"string\",\n      \"description\": \"Company or merchant name\"\n    },\n    \"items\": {\n      \"type\": \"array\",\n      \"description\": \"List of purchased items\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"item_name\": {\n            \"type\": \"string\",\n            \"description\": \"Product or service name\"\n          },\n          \"item_cost\": {\n            \"type\": \"number\",\n            \"description\": \"Price per unit (numeric only)\"\n          },\n          \"item_quantity\": {\n            \"type\": \"integer\",\n            \"description\": \"Number of units purchased\",\n            \"default\": 1\n          },\n          \"item_currency\": {\n            \"type\": \"string\",\n            \"description\": \"Currency code (ISO 4217)\",\n            \"pattern\": \"^[A-Z]{3}$\"\n          }\n        },\n        \"required\": [\"item_name\", \"item_cost\", \"item_quantity\", \"item_currency\"],\n        \"additionalProperties\": false\n      },\n      \"minItems\": 1\n    }\n  },\n  \"required\": [\"seller_name\", \"items\"],\n  \"additionalProperties\": false\n}"
            }
          }
        }
      },
      "id": "0decd680-cd23-4dd9-a026-55c20e6d7b88",
      "name": "Extract Invoice Data with AI",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 2,
      "position": [
        848,
        1488
      ],
      "credentials": {
        "openAiApi": {
          "id": "eJNHP6n8O3Y9Iv2F",
          "name": "Open Ai - IC"
        }
      }
    },
    {
      "parameters": {
        "fieldToSplitOut": "items",
        "include": "allOtherFields",
        "options": {}
      },
      "id": "2328a563-2b6b-46a1-9ca5-203aff617a57",
      "name": "Split Items2",
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        2768,
        1488
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "b0fd4581-9d46-46c0-8b2f-6dcefab9c854",
              "name": "RETORO_API_KEY",
              "value": "299f5ca754fa16718420949736b75abb139ff5018f792a00c961b99a97716fa7",
              "type": "string"
            },
            {
              "id": "05cf9493-ddc9-47dd-8de8-520eeab97809",
              "name": "RETORO_API_URL",
              "value": "https://your.retoro.app/api",
              "type": "string"
            },
            {
              "id": "user-id-field",
              "name": "user_id",
              "value": "={{ $json.user_id }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1424,
        1488
      ],
      "id": "c639c66b-2997-4bb0-96cb-f70c1bf017a1",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "documentType": "image_url",
        "options": {}
      },
      "type": "n8n-nodes-base.mistralAi",
      "typeVersion": 1,
      "position": [
        624,
        1488
      ],
      "id": "83172eb7-db16-4e58-b90b-8b4163593dfc",
      "name": "Extract text",
      "credentials": {
        "mistralCloudApi": {
          "id": "WZEuqlC6d4b4G4dV",
          "name": "Mistral Cloud account"
        }
      }
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "chatgpt-4o-latest",
          "mode": "list",
          "cachedResultName": "CHATGPT-4O-LATEST"
        },
        "responses": {
          "values": [
            {
              "content": "=Analyze the following text extracted from an uploaded document and determine if it is an invoice, receipt, or payment confirmation.\n\nText to analyze:\n{{ $json.pages[0].markdown }}\n\nYour task:\n1. Determine if this document is an invoice, receipt, or payment confirmation\n2. Look for indicators such as:\n   - Seller/merchant name\n   - Itemized list of products or services\n   - Prices and totals\n   - Payment information\n   - Invoice/receipt numbers\n   - Dates\n\nReturn ONLY a JSON object with this structure:\n{\n  \"is_valid_invoice\": true/false,\n  \"document_type\": \"invoice\" | \"receipt\" | \"payment_confirmation\" | \"other\",\n  \"confidence\": 0.0-1.0\n}\n\nIf the document is clearly NOT an invoice/receipt/payment confirmation (e.g., random image, screenshot, document without purchase information), set is_valid_invoice to false."
            }
          ]
        },
        "builtInTools": {},
        "options": {
          "textFormat": {
            "textOptions": {
              "type": "json_schema",
              "schema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"is_valid_invoice\": {\n      \"type\": \"boolean\",\n      \"description\": \"Whether this is a valid invoice, receipt, or payment confirmation\"\n    },\n    \"document_type\": {\n      \"type\": \"string\",\n      \"enum\": [\"invoice\", \"receipt\", \"payment_confirmation\", \"other\"],\n      \"description\": \"Type of document\"\n    },\n    \"confidence\": {\n      \"type\": \"number\",\n      \"minimum\": 0,\n      \"maximum\": 1,\n      \"description\": \"Confidence level (0.0 to 1.0)\"\n    }\n  },\n  \"required\": [\"is_valid_invoice\", \"document_type\", \"confidence\"],\n  \"additionalProperties\": false\n}"
            }
          }
        }
      },
      "id": "validate-invoice-node-id",
      "name": "Validate Invoice",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 2,
      "position": [
        736,
        1488
      ],
      "credentials": {
        "openAiApi": {
          "id": "eJNHP6n8O3Y9Iv2F",
          "name": "Open Ai - IC"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "invoice-validation-condition",
              "leftValue": "={{ $json.is_valid_invoice }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        792,
        1488
      ],
      "id": "check-if-invoice-node-id",
      "name": "Check If Invoice"
    },
    {
      "parameters": {
        "jsCode": "// Preserve original text data from Extract text node for Extract Invoice Data with AI\nconst originalTextData = $('Extract text').item.json;\nconst validationResult = $input.item.json;\n\n// Merge validation result with original text data\nreturn {\n  json: {\n    ...originalTextData, // Preserve pages[0].markdown for extraction\n    validation: validationResult // Keep validation info for reference\n  }\n};"
      },
      "id": "preserve-text-data-node-id",
      "name": "Preserve Text Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        904,
        1488
      ]
    },
    {
      "parameters": {
        "jsCode": "// Get user_id from webhook query parameters\nconst webhookData = $('Webhook Trigger1').item.json;\nconst userId = webhookData.query?.user_id || webhookData.user_id || webhookData.userId;\n\n// Get validation result\nconst validationResult = $('Validate Invoice').item.json;\n\nreturn {\n  json: {\n    error: true,\n    message: \"Sorry, this is not a valid invoice. Please add your purchase manually using the form below.\",\n    document_type: validationResult.document_type || \"other\",\n    confidence: validationResult.confidence || 0,\n    user_id: userId\n  }\n};"
      },
      "id": "error-response-node-id",
      "name": "Format Error Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        792,
        1680
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "respond-error-node-id",
      "name": "Respond with Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1000,
        1680
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "invoice-process",
        "responseMode": "lastNode",
        "options": {
          "binaryData": true
        }
      },
      "id": "83490f19-3836-415a-9d34-b72ebd54c7ab",
      "name": "Webhook Trigger1",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        400,
        1488
      ],
      "webhookId": "invoice-process"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "b1c274f3-142f-4031-bae2-bf8d0697c855",
      "name": "Respond to Webhook1",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        3664,
        1488
      ]
    }
  ],
  "connections": {
    "Check If Retailer Exists": {
      "main": [
        [
          {
            "node": "Split Items2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create Retailer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Retailer": {
      "main": [
        [
          {
            "node": "Format Created Retailer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Created Retailer": {
      "main": [
        [
          {
            "node": "Split Items2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Invoice Data1": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search Retailer2": {
      "main": [
        [
          {
            "node": "Match Retailer2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Match Retailer2": {
      "main": [
        [
          {
            "node": "Check If Retailer Exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Return Item2": {
      "main": [
        [
          {
            "node": "Aggregate Results2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Results2": {
      "main": [
        [
          {
            "node": "Respond to Webhook1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Invoice Data with AI": {
      "main": [
        [
          {
            "node": "Parse Invoice Data1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Items2": {
      "main": [
        [
          {
            "node": "Create Return Item2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Search Retailer2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract text": {
      "main": [
        [
          {
            "node": "Validate Invoice",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Invoice": {
      "main": [
        [
          {
            "node": "Check If Invoice",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check If Invoice": {
      "main": [
        [
          {
            "node": "Preserve Text Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Format Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preserve Text Data": {
      "main": [
        [
          {
            "node": "Extract Invoice Data with AI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Error Response": {
      "main": [
        [
          {
            "node": "Respond with Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Trigger1": {
      "main": [
        [
          {
            "node": "Extract text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "c0320382499acc1816c05e1130ede806d6731eecdef3b30ac30aabf4236c8764"
  }
}